<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Programme de ménage</title>
  <!-- Quasar CSS UMD pour Vue 3 / Quasar 2 -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons" rel="stylesheet"
    type="text/css">
  <link href="https://cdn.jsdelivr.net/npm/quasar@2.18.1/dist/quasar.prod.css" rel="stylesheet" type="text/css">
</head>

<body>
  <div id="q-app" class="column flex" style="height:100vh; margin:0">
    <div class="col print-hide" style="overflow-y: scroll;">
      <q-tabs v-model="panel" inline-label outside-arrows mobile-arrows class="bg-primary text-white shadow-2">
        <q-tab :name="room.id" :label="room.label" v-for="room in rooms" :key="room.id">
        </q-tab>
      </q-tabs>
      <!-- Boucle sur les pièces -->
      <q-tab-panels v-model="panel" animated swipeable infinite class="shadow-2 rounded-borders">
        <q-tab-panel :name="room.id" v-for="room in rooms" :key="room.id">
          <q-card flat bordered>
            <q-card-section class="bg-blue-grey-6 text-grey-2 text-h4">
              <q-checkbox dark v-model="selectedRooms" :val="room.id" :label="room.label"
                @update:model-value="(val) => changeRoom(val, room)">
              </q-checkbox>
            </q-card-section>
            <q-card-section class="no-padding">
              <template v-for="(tasks, key) in tasksByRoom(room.id)" :key="key">
                <q-list separator :class="'bg-' + bgColor[key] + '-2'">
                  <q-item v-for="task in tasks" class="col-12 items-center">
                    <q-item-section >
                      <q-checkbox v-model="selectedTasks[room.id]" :val="task.travailId"
                      :label="`${workMap[task.travailId].label}`">
                    </q-checkbox>
                    
                  </q-item-section>
                  <q-item-section avatar>
                    {{`${estimateDuration(room.id, task.travailId)}`}}
                    <q-item-section>
                  </q-item>
                </q-list>
                <q-separator></q-separator>
              </template>
            </q-card-section>
          </q-card>
        </q-tab-panel>
      </q-tab-panels>
    </div>

    <div class=" col-12 print-only ">
      <div class="row items-center">
        <div class="col-8 text-h3">Week</div>
        <div class="col-4 text-right text-h5">
          <div>{{(new Date()).toLocaleDateString('fr-FR')}}</div>
          <div class="text-caption">{{Math.floor(timeWorkList/60)}} h {{(timeWorkList%60) || 0}} min</div>
        </div>
        <div class="col-12 q-mb-lg">
        <q-separator></q-separator>
        </div>
        <template v-for="(works,room) in schedule" :key="room">
        <div class="col-6 q-pa-md" v-if="works?.length && works[0]?.room" >
          <div class="row justify-end item-center">
            <div class="col-10 bg-grey-2 text-uppercase text-h5 q-pl-sm">
              {{works[0]?.room}}
            </div>
            <div class="col-2 bg-grey-2 text-uppercase text-right q-pr-sm">
              <q-chip outline size="sm">
              {{works[0]?.etage}}
              </q-chip>
            </div>
            <div class="col-11">
              <q-list dense separator bordered>
                <q-item v-for="work in works" :key="work.id">
                  {{work.work}}
                </q-item>
              </q-list>
            </div>
          </div>
        </div>
        </template>
      </div>
    </div>
    <div class="relative-position col-auto q-pa-md bg-blue-grey-8 text-grey-2 print-hide" style="min-height:50px">
      <q-badge floating class="cursor-pointer q-mx-md q-pa-xs text-grey-7" color="grey-3" @click="printSchedule()">
        <q-icon class="q-pr-xs" name="print"></q-icon> {{Math.floor(timeWorkList/60)}} h {{(timeWorkList%60) || 0}} min
      </q-badge>
      <div class="row">
        <div class="col-12">
          <q-chip square size="sm" v-for="(conso, key) in consoWorkList" :label="key + ' : ' + conso"></q-chip>
        </div>
      </div>
    </div>
  </div>
  </div>

  <!-- Librairies UMD -->
  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/quasar@2.18.1/dist/quasar.umd.prod.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script>
    // Récupération des modules
    const { createApp } = Vue;
    const QuasarPlugin = window.Quasar;
    const _ = window._;
    let lang = ''
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('lang')) {
      lang = '-' +urlParams.get('lang');
    }
    // Charger les JSON
    Promise.all([
      fetch('data/room'+lang+'.json').then(r => r.json()),
      fetch('data/work'+lang+'.json').then(r => r.json()),
      fetch('data/room-work.json').then(r => r.json())
    ]).then(([rooms, workList, roomWorkList]) => {
      rooms = _.sortBy(rooms, r => `${r.etage}#${r.label}`)
      const app = createApp({
        data() {
          return {
            panel: null,
            rooms,
            workList,
            roomWorkList,
            selectedRooms: [],
            selectedTasks: {},
            bgColor: { 'A':'teal','W': 'green', 'M': 'orange', 'Y': 'red' }

          };
        },
        computed: {
          schedule() {
            return _.reduce(this.selectedTasks, (memo, tasks, room) => {
              const roomLocal = _.find(this.rooms, w => w.id == room)
              if (!memo[roomLocal.etage + '#' + roomLocal.label]) {
                memo[roomLocal.etage + '#' + roomLocal.label] = []
              }
              _.each(tasks, task => {
                
                const work = _.find(this.workList, w => w.id == task)
                const item  = _.find(this.roomWorkList, r => r.pieceId === room && r.travailId === task)
                memo[roomLocal.etage + '#' + roomLocal.label].push(
                  {room: roomLocal?.label, etage:roomLocal?.etage,work: work.label, frequence:item.frequence}
                )
              })
              return memo
            }, {})
          },
          timeWorkList() {
            return _.reduce(this.selectedTasks, (memo, tasks, room) => {
              return _.reduce(tasks, (memo1, task) => {
                const item  = _.find(this.roomWorkList, r => r.pieceId === room && r.travailId === task)
                if (!item) {
                  return memo1
                }
                return memo1 + ((['A'].includes(item.frequence)  ? 2 : 1) * item?.duree || 0)
              }, 0) + memo
            }, 0)
          },
          consoWorkList() {
            return _.reduce(this.selectedTasks, (memo, tasks, room) => {
              _.each(tasks, (task) => {
                const consos = _.find(this.workList, w => w.id == task)?.consommables
                if (!consos?.length) { return }
                _.each(consos, conso => {
                  if (!memo[conso]) {
                    memo[conso] = 0
                  }
                  memo[conso]++
                })
              })
              return memo
            }, {})
          },
          workMap() {
            return _.keyBy(this.workList, 'id');
          }
        },
        created() {

          this.panel = this.rooms[0].id
          // Init selectedTasks pour chaque pièce
          this.rooms.forEach(r => {
            this.selectedTasks[r.id] = [];
            this.selectedRooms.push(r.id)
            this.changeRoom(this.selectedRooms, r)
          });
        },
        methods: {
          changeRoom(val, room) {
            const toAdd = val.includes(room.id)
            _.each(this.roomWorkList, rw => {
              if (rw.pieceId !== room.id) { return }
              if (!['A','W'].includes(rw.frequence)) { return }
              if (toAdd) {
                this.selectedTasks[room.id].push(rw.travailId)
              } else {

                _.remove(this.selectedTasks[room.id], r => r === rw.travailId)
              }

            })
          },
          tasksByRoom(roomId) {
            // Liste des taches pour une piece.
            return _.groupBy(_.filter(this.roomWorkList, rw => rw.pieceId === roomId), rw => rw.frequence);
          },
          estimateDuration(roomId, travailId) {
            const rw = _.find(this.roomWorkList, { pieceId: roomId, travailId });
            return rw && rw.duree ? `${rw.duree} min` : '';
          },
          consumablesFor(travailId) {
            return _.get(this.workMap, [travailId, 'consommables'], []);
          },
          generateSchedule() {
            this.schedule = [];
            _.forEach(this.selectedRooms, roomId => {
              _.forEach(this.selectedTasks[roomId], tid => {
                const room = _.find(this.rooms, { id: roomId });
                const task = this.workMap[tid];
                this.schedule.push({
                  room: roomId,
                  roomLabel: room.label,
                  task: tid,
                  taskLabel: task.label
                });
              });
            });
          },
          printSchedule() {
            window.print();
          }
        }
      });

      // Activation de Quasar et montage
      app.use(QuasarPlugin);
      app.mount('#q-app');
    });
  </script>
</body>

</html>